/*
 * Copyright 2015 The Guardian
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lib

import akka.agent.Agent

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.{Future, Promise}

/**
 * Requirements:
 *
 * 0. Only ONE scan must happen at any given time
 * 1. When a scan is requested, a scan MUST take place at some point in the future.
 * 2. A scan that is currently running does not count, a fresh scan must be done AFTERWARDS
 * 3. Scan requests that can not be run immediately should be aggregated into a single request
 *
 * @param thing
 * @tparam R the result type generated by the scan
 */
class Dogpile[R](thing: => Future[R]) {
/*
  currently executing scan?
  upcoming scan?

  States:
  * No scan running
  * Scan running
  * Scan running, another scan requested

  OR

  * Can run scan immediately
  * Must wait (future already generated or not?)

  Should agent store futures? We never want the result of the *currently running* future - but we DO
  want a reference to the future of the *upcoming* scan, so that we can share it among requesters.
*/

  sealed trait State {
    val scanFuture: Future[R]
  }
  case class ScanRun(scanFuture: Future[R]) extends State
  case class ScanQueued(scanFuture: Future[R]) extends State

  private val agent: Agent[State] = Agent(ScanRun(Future.failed(new IllegalStateException())))

  /**
   *
   * @return a future for a run which has been initiated at or after this call
   */
  def doAtLeastOneMore(): Future[R] = agent.alter { previousState =>
    if (previousState.scanFuture.isCompleted) ScanRun(thing) else {
      previousState match {
        case ScanQueued(_) => previousState
        case ScanRun(s) => {
          val p = Promise[R]()
          s.onComplete(_ => p.completeWith(thing))
          ScanQueued(p.future)
        }
      }
    }
  }.flatMap(_.scanFuture)
}

